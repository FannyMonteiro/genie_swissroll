PROGRAM errfn_ea_go_gs
!
! Calculate the cost function for the ea_go_gs problem
!
! The binary generated by this code is designed to post-process the 
! netcdf output from the ea_go_gs model and calculate the same RMS
! error function as reported during the model run. This binary should
! reside in the same location as the genie.exe binary and will read
! the goin files in that directory to find the details of the data
! directories, topography files and observational data files. The
! error functions are calculated by providing the model data and
! observational data to the appropriate error function codes. RMS
! error values are output in the file errfn_ea_go_gs.err.
!
! Andrew Price - 19/12/06
! SAM -  15/07/2010: updated to work with latest version of the model
!
use genie_control
use genie_global
IMPLICIT NONE
INCLUDE '../../netcdf.inc'

! Grids
INTEGER, PARAMETER :: imax=ilon1_ocn, jmax=ilat1_ocn, kmax=inl1_ocn

! Observational Data
REAL, DIMENSION(imax,jmax,kmax,1) :: ocn_tavg, ocn_savg
REAL, DIMENSION(imax,jmax,kmax)   :: ocn_temp, ocn_sal
REAL, DIMENSION(imax,jmax,1)      :: surf_tavg, surf_qdryavg, surf_rqdryavg

! RMS error values and functions
REAL               :: err1, err2, err3, err4
REAL               :: err_gold, err_embm

! EMBM input/output directories
INTEGER            :: embm_lenin, embm_lenout
CHARACTER(LEN=200) :: embm_indir_name, embm_outdir_name

! EMBM T/Q data files
INTEGER            :: embm_lentdata, embm_lenqdata
CHARACTER(LEN=128)  :: embm_tdatafile, embm_qdatafile
CHARACTER(LEN=3)   :: embm_lout
CHARACTER(LEN=25) :: embm_tdata_varname,embm_qdata_varname
REAL :: embm_tdata_missing,embm_tdata_scaling,embm_tdata_offset
REAL :: embm_qdata_missing,embm_qdata_scaling,embm_qdata_offset
LOGICAL :: embm_tqinterp,embm_qdata_rhum
INTEGER :: embm_igrid

! Grid axes
! Use variables defined in ../../genie_global.f90
REAL :: loc_pi

! Bathymetry
CHARACTER(LEN=6)   :: world
INTEGER            :: ntot1, ntot2
INTEGER, DIMENSION(0:imax+1,0:jmax+1) :: k1

! GOLD input/output directories
INTEGER            :: gold_lenin, gold_lenout
CHARACTER(LEN=200) :: gold_indir_name, gold_outdir_name

! GOLD T/S data files
INTEGER            :: gold_lentdata, gold_lensdata
CHARACTER(LEN=128)  :: gold_tdatafile, gold_sdatafile
CHARACTER(LEN=3)   :: gold_lout
CHARACTER(LEN=25) ::  gold_tdata_varname,gold_sdata_varname
REAL :: gold_tdata_missing,gold_tdata_scaling,gold_tdata_offset
REAL :: gold_sdata_missing,gold_sdata_scaling,gold_sdata_offset
LOGICAL :: gold_tsinterp
REAL :: gold_saln0
INTEGER :: gold_igrid

! Model data files
INTEGER            :: model_lentdata
CHARACTER(LEN=200) :: model_tdatafile

! NetCDF variables
INTEGER            :: ncid, status
CHARACTER(LEN=256) :: filename

! string length function
INTEGER            :: lnsig1

! Indices
! INTEGER            :: i,j
INTEGER            :: k

! Data scaling
! These are hard coded scaling factors that need to match the equivalent definitions in err_gold.f and err_embm.f
! REAL, PARAMETER    :: saln0=34.9
REAL, PARAMETER    :: humscale=1000.

! Configuration of the error function
CHARACTER(LEN=256) :: configfile
LOGICAL            :: exists
CHARACTER(LEN=13)  :: yearstr

!======================================================================
! Initialise
!
! Assume: this binary is executing in same location as genie.exe and
!         therefore goin_* and data_* files are available which will
!         tell us where the data is
!======================================================================

! Check that the configuration file exists
configfile='errfn_ea_go_gs.config'
INQUIRE(FILE=trim(configfile), EXIST=exists)
if (.NOT. exists) then
    print*,'Could not find the configuration file for the ea_go_gs error calculation'
    STOP
end if

! Read the local configuration file for the error calculation
open(unit=431, file='errfn_ea_go_gs.config')
read(431,*) yearstr
close(431)
print*,'Processing av_',yearstr

! Process the goin_EMBM file
CALL read_goin_EMBM(embm_indir_name, embm_lenin, &
                    embm_outdir_name, embm_lenout, &
                    embm_tdatafile, embm_lentdata, &
                    embm_qdatafile, embm_lenqdata, embm_lout, world, &
                    embm_tqinterp, embm_tdata_scaling, embm_tdata_offset, &
                    embm_tdata_varname, &
                    embm_tdata_missing, embm_qdata_scaling, &
                    embm_qdata_offset, &
                    embm_qdata_varname, embm_qdata_missing, &
                    embm_qdata_rhum,embm_igrid)

! Process the goin_GOLD file
CALL read_goin_GOLD(gold_indir_name, gold_lenin, &
                    gold_outdir_name, gold_lenout, &
                    gold_tdatafile, gold_lentdata, &
                    gold_sdatafile, gold_lensdata, gold_lout, world, &
                    gold_tsinterp, gold_tdata_scaling, gold_tdata_offset, &
                    gold_tdata_varname, &
                    gold_tdata_missing, gold_sdata_scaling, &
                    gold_sdata_offset, &
                    gold_sdata_varname, gold_sdata_missing, &
                    gold_saln0,gold_igrid)

!======================================================================
! Generate grid axes (temporary solution): For now, these axes
! definitions have to be kept in sync with the definitions found in
! genie-embm/src/fortran/initialise_embm.F and
! genie-goldstein/src/fortran/initioalise_goldstein.F. At a later
! stage, the axes vectors should be provided by the respective modules
! themselves which will render the axes definitions below obsolete.
! ======================================================================
! Longitude
loc_pi=4.*atan(1.)
if ((embm_igrid.eq.0).or.(gold_igrid.eq.1)) then
   do i=1,imax
      alon1_atm(i)=360.0*(i-0.5)/real(imax)-260.
   end do
else if (gold_igrid.eq.2) then
   do i=1,imax
      alon1_atm(i)=(i-1.0)*360./imax
   enddo
endif
if ((gold_igrid.eq.0).or.(gold_igrid.eq.1)) then
   do i=1,imax
      alon1_ocn(i)=360.0*(i-0.5)/real(imax)-260.
   end do
else if (gold_igrid.eq.2) then
   do i=1,imax
      alon1_ocn(i)=(i-1.0)*360./imax
   enddo
endif
! Latitude
if(embm_igrid.eq.1)then
   do j=1,jmax
      alat1_atm(j)=-90.+(j-0.5)*90./jmax
   enddo
elseif(embm_igrid.eq.0)then
   do j=1,jmax
      alat1_atm(j)=180.*asin(-1.+2.*real(j-0.5)/real(jmax))/loc_pi
   enddo
elseif(embm_igrid.eq.2)then
   call gwtcnr(alat1_atm,jmax/2)
endif
if(gold_igrid.eq.1)then
   do j=1,jmax
      alat1_ocn(j)=-90.+(j-0.5)*90./jmax
   enddo
elseif(gold_igrid.eq.0)then
   do j=1,jmax
      alat1_ocn(j)=180.*asin(-1.+2.*real(j-0.5)/real(jmax))/loc_pi
   enddo
elseif(gold_igrid.eq.2)then
   call gwtcnr(alat1_ocn,jmax/2)
endif
! Depth
do k=kmax,1,-1
   depth1_ocn(kmax+1-k) = 500.*(11.0**((k-0.5)/real(kmax))-1.)
enddo

!======================================================================
! Load the ocean bathymetry
!======================================================================

! AY (01/12/03) : line modified to point to input directory
print*,'ocean bathymetry being read in'
print*,'Loading: ',gold_indir_name(1:gold_lenin)//world//'.k1'
open(13,file=gold_indir_name(1:gold_lenin)//world//'.k1')
! note k1(i,j) must be periodic ; k1(0,j) - k1(imax,j) = 0 and
! k1(1,j) - k1(imax+1,j) = 0, as enforced below;

do j=jmax+1,0,-1
    read(13,*)(k1(i,j),i=0,imax+1)
! rotate grid to check b.c.s
    k1(0,j) = k1(imax,j)
    k1(imax+1,j) = k1(1,j)
    write(6,'(i4,66i3)')j,(k1(i,j),i=0,imax+1)
enddo
close(13)

!======================================================================
! Load the annually averaged model data from the selected output file
!======================================================================

! Retrieve the annual average fields from the EMBM NetCDF output
model_tdatafile='embm_'//embm_lout//'_av_'//yearstr//'.nc'
model_lentdata =lnsig1(model_tdatafile)
filename       =trim(embm_outdir_name(1:embm_lenout))//trim(model_tdatafile(1:model_lentdata))
print*,'EMBM model data file: ',trim(filename)
status=nf_open(trim(filename), 0, ncid)
IF (STATUS .NE. NF_NOERR) CALL CHECK_ERR(STATUS)
call get3d_data_nc(ncid, 'air_temp', imax, jmax, 1, surf_tavg, status)
IF (STATUS .NE. NF_NOERR) CALL CHECK_ERR(STATUS)
call get3d_data_nc(ncid, 'dry_air_humidity', imax, jmax, 1, surf_qdryavg, status)
IF (STATUS .NE. NF_NOERR) CALL CHECK_ERR(STATUS)
call get3d_data_nc(ncid, 'dry_air_relative_humidity', imax, jmax, 1, surf_rqdryavg, status)
IF (STATUS .NE. NF_NOERR) CALL CHECK_ERR(STATUS)
status=nf_close(ncid)

! Retrieve the annual average fields from the GOLD NetCDF output
model_tdatafile='gold_'//gold_lout//'_av_'//yearstr//'.nc'
model_lentdata =lnsig1(model_tdatafile)
filename       =trim(gold_outdir_name(1:gold_lenout))//trim(model_tdatafile(1:model_lentdata))
print*,'GOLD model data file: ',filename
status=nf_open(trim(filename), 0, ncid)
IF (STATUS .NE. NF_NOERR) CALL CHECK_ERR(STATUS)
call get4d_data_nc(ncid, 'temp', imax, jmax, kmax, 1, ocn_tavg, status)
IF (STATUS .NE. NF_NOERR) CALL CHECK_ERR(STATUS)
call get4d_data_nc(ncid, 'salinity', imax, jmax, kmax, 1, ocn_savg, status)
IF (STATUS .NE. NF_NOERR) CALL CHECK_ERR(STATUS)
status=nf_close(ncid)

!======================================================================
! Calculate the individual RMS errors for each field
!======================================================================

! Transform the netcdf data back to the model representation
do k=1,kmax
    ocn_temp(:,:,k)=ocn_tavg(:,:,kmax-k+1,1)
    ocn_sal(:,:,k) =ocn_savg(:,:,kmax-k+1,1)
end do
ocn_sal=ocn_sal-gold_saln0
surf_qdryavg=surf_qdryavg/humscale

! Calculate the error functions
ntot1=0
err1 = err_gold(ocn_temp, 1, k1, ntot1, imax, jmax, kmax, gold_indir_name, gold_lenin, gold_tdatafile, gold_lentdata, gold_tdata_scaling, gold_tdata_offset, gold_tsinterp, gold_tdata_varname, gold_tdata_missing, alon1_ocn, alat1_ocn, depth1_ocn)

ntot2=0
err2 = err_gold(ocn_sal, 2, k1, ntot2, imax, jmax, kmax, gold_indir_name, gold_lenin, gold_sdatafile, gold_lensdata, gold_sdata_scaling, gold_sdata_offset+gold_saln0, gold_tsinterp, gold_sdata_varname, gold_sdata_missing, alon1_ocn, alat1_ocn, depth1_ocn)

err3 = err_embm(surf_tavg, 1, imax, jmax, embm_indir_name, embm_lenin, embm_tdatafile, embm_lentdata, embm_tdata_scaling, embm_tdata_offset, embm_tqinterp, embm_tdata_varname, embm_tdata_missing, alon1_atm, alat1_atm)

if (embm_qdata_rhum) then
   err4 = err_embm(surf_rqdryavg, 2, imax, jmax, embm_indir_name, embm_lenin, embm_qdatafile, embm_lenqdata, embm_qdata_scaling, embm_qdata_offset, embm_tqinterp, embm_qdata_varname, embm_qdata_missing, alon1_atm, alat1_atm)
else
   err4 = err_embm(surf_qdryavg, 2, imax, jmax, embm_indir_name, embm_lenin, embm_qdatafile, embm_lenqdata, embm_qdata_scaling, embm_qdata_offset, embm_tqinterp, embm_qdata_varname, embm_qdata_missing, alon1_atm, alat1_atm)
endif

!======================================================================
! Calculate a composite cost function
!======================================================================

! Original C-GOLDSTEIN composition
print *,'C-GOLDSTEIN error: ',sqrt( ((err1**2*ntot1) + (err2**2*ntot2) + (err3**2*imax*jmax) + (err4**2*imax*jmax)) &
                                   / (ntot1 + ntot2 + (imax*jmax) + (imax*jmax)) )
print *,'ntot1: ',ntot1,' ntot2: ',ntot2

open(unit=433, file='errfn_ea_go_gs.err')
write(433,435) err1, err2, err3, err4, sqrt( ((err1**2*ntot1) + (err2**2*ntot2) + (err3**2*imax*jmax) + (err4**2*imax*jmax)) &
                                   / (ntot1 + ntot2 + (imax*jmax) + (imax*jmax)) )
435 format(5f20.16)
close(433)

END PROGRAM errfn_ea_go_gs


! =====================================================================
! Read the local goin_EMBM file for the following information:
! 
!    indir_name
!    outdir_name
!    tdatafile
!    qdatafile
!
SUBROUTINE read_goin_EMBM(indir_name, lenin, &
                          outdir_name, lenout, &
                          tdatafile, lentdata, &
                          qdatafile, lenqdata, lout, world, &
                          tqinterp, tdata_scaling, tdata_offset, &
                          tdata_varname, &
                          tdata_missing, qdata_scaling, &
                          qdata_offset, &
                          qdata_varname, qdata_missing, igrid)
IMPLICIT NONE

! string length function
INTEGER :: lnsig1

! EMBM input/output directory
INTEGER :: lenin, lenout
CHARACTER(LEN=200) :: indir_name, outdir_name

! EMBM T/Q data files
INTEGER :: lentdata, lenqdata
CHARACTER(LEN=128) :: tdatafile, qdatafile
CHARACTER(LEN=25) :: tdata_varname,qdata_varname
REAL :: tdata_missing,tdata_scaling,tdata_offset
REAL :: qdata_missing,qdata_scaling,qdata_offset
LOGICAL :: tqinterp,qdata_rhum

! File extension
CHARACTER(LEN=3) :: lout
CHARACTER(LEN=6) :: world

! File inquiry
LOGICAL exists

! Variables in the namelist we are not interested in here
INTEGER :: igrid, npstp, iwstp, itstp, ianav, nyear, ndta, aaa
INTEGER :: t_orbit, norbit, orbitsteps, t_co2, nco2, co2steps
INTEGER :: diffa_len, albedop_skewp, orogswitch, t_orog, norog
INTEGER :: orogsteps, t_lice, nlice, licesteps, t_d18o, nd18o
INTEGER :: d18osteps, ents_seasonswitch, ents_offlineswitch
LOGICAL :: dosc, useforc
REAL :: yearlen, scf, diffwid, difflin
REAL :: scl_co2, pc_co2_rise, tatm, relh0_ocean, relh0_land
REAL :: extra1a, extra1b, extra1c, scl_fwf, z1_embm, albedoice
REAL :: grnla, lgm
REAL :: radfor_scl_co2, radfor_pc_co2_rise
REAL :: radfor_scl_ch4, radfor_pc_ch4_rise
REAL :: radfor_scl_n2o, radfor_pc_n2o_rise
REAL :: u_tau_ice, ch_ice, cpo_ice, rmax, diffa_scl
REAL :: delf2x, olr_adj0, olr_adj, t_eqm, aerofac, volfac, solfac
REAL :: albedop_offs, albedop_amp, albedop_skew, albedop_mod2
REAL :: albedop_mod4, albedop_mod6, albedop_scl, lapse_rate
REAL :: lice_k9, d18o_k, scale_mwfx, timepptn
REAL, DIMENSION(2) :: diffamp, betaz, betam
CHARACTER(LEN=200) :: filenameco2, filenameorog, filenamelice
CHARACTER(LEN=200) :: rstdir_name, filenameorbit
CHARACTER(LEN=200) :: filenamed18o, filenamed18oicethresh
CHARACTER(LEN=200) :: filenamed18oorogmin, filenamed18ooroggrad
CHARACTER(LEN=20) :: xu_wstress, yu_wstress, xv_wstress, yv_wstress
CHARACTER(LEN=20) :: u_wspeed, v_wspeed, ans, netin, netout, ascout
CHARACTER(LEN=20) :: filenetin, dirnetout, lin, atchem_radfor
CHARACTER(LEN=20) :: ents_radfor, orbit_radfor, forcname

! declare a namelist to store EMBM's initialisation vars
NAMELIST /ini_embm_nml/indir_name,outdir_name
NAMELIST /ini_embm_nml/rstdir_name
NAMELIST /ini_embm_nml/igrid,world
NAMELIST /ini_embm_nml/xu_wstress,yu_wstress,xv_wstress
NAMELIST /ini_embm_nml/yv_wstress,u_wspeed,v_wspeed
NAMELIST /ini_embm_nml/npstp,iwstp,itstp,ianav,ans
NAMELIST /ini_embm_nml/yearlen,nyear,ndta,scf
NAMELIST /ini_embm_nml/diffamp,diffwid,difflin
NAMELIST /ini_embm_nml/betaz,betam
NAMELIST /ini_embm_nml/radfor_scl_co2,radfor_pc_co2_rise
NAMELIST /ini_embm_nml/radfor_scl_ch4,radfor_pc_ch4_rise
NAMELIST /ini_embm_nml/radfor_scl_n2o,radfor_pc_n2o_rise
NAMELIST /ini_embm_nml/tatm,relh0_ocean,relh0_land
NAMELIST /ini_embm_nml/extra1a,extra1b,extra1c,scl_fwf
NAMELIST /ini_embm_nml/z1_embm,tdatafile,qdatafile
NAMELIST /ini_embm_nml/tdata_varname,qdata_varname
NAMELIST /ini_embm_nml/tdata_missing,qdata_missing
NAMELIST /ini_embm_nml/tdata_scaling,qdata_scaling
NAMELIST /ini_embm_nml/tdata_offset,qdata_offset
NAMELIST /ini_embm_nml/qdata_rhum
NAMELIST /ini_embm_nml/tqinterp
NAMELIST /ini_embm_nml/lout,netin,netout,ascout
NAMELIST /ini_embm_nml/rmax
NAMELIST /ini_embm_nml/filenetin,dirnetout
NAMELIST /ini_embm_nml/lin,atchem_radfor
NAMELIST /ini_embm_nml/ents_radfor,orbit_radfor
NAMELIST /ini_embm_nml/t_orbit,norbit,orbitsteps,filenameorbit
NAMELIST /ini_embm_nml/t_co2,nco2,co2steps,filenameco2
NAMELIST /ini_embm_nml/diffa_scl,diffa_len
NAMELIST /ini_embm_nml/dosc,delf2x
NAMELIST /ini_embm_nml/olr_adj0,olr_adj,t_eqm
NAMELIST /ini_embm_nml/aerofac,volfac,solfac
NAMELIST /ini_embm_nml/useforc,forcname
NAMELIST /ini_embm_nml/albedop_offs,albedop_amp
NAMELIST /ini_embm_nml/albedop_skew,albedop_skewp
NAMELIST /ini_embm_nml/albedop_mod2,albedop_mod4,albedop_mod6
NAMELIST /ini_embm_nml/lapse_rate
NAMELIST /ini_embm_nml/orogswitch
NAMELIST /ini_embm_nml/t_orog
NAMELIST /ini_embm_nml/filenameorog
NAMELIST /ini_embm_nml/norog
NAMELIST /ini_embm_nml/orogsteps
NAMELIST /ini_embm_nml/t_lice
NAMELIST /ini_embm_nml/filenamelice
NAMELIST /ini_embm_nml/nlice
NAMELIST /ini_embm_nml/licesteps
NAMELIST /ini_embm_nml/lice_k9
NAMELIST /ini_embm_nml/t_d18o
NAMELIST /ini_embm_nml/nd18o
NAMELIST /ini_embm_nml/d18osteps
NAMELIST /ini_embm_nml/d18o_k
NAMELIST /ini_embm_nml/scale_mwfx
NAMELIST /ini_embm_nml/filenamed18o
NAMELIST /ini_embm_nml/filenamed18oicethresh
NAMELIST /ini_embm_nml/filenamed18oorogmin
NAMELIST /ini_embm_nml/filenamed18ooroggrad
NAMELIST /ini_embm_nml/ents_seasonswitch
NAMELIST /ini_embm_nml/ents_offlineswitch
NAMELIST /ini_embm_nml/timepptn

! Process the EMBM goin file
INQUIRE(FILE='data_EMBM', EXIST=exists)
IF (.NOT. exists) THEN
    PRINT*,'Cannot find ./data_EMBM'
    STOP
END IF

! Read the EMBM GOIN file
open(unit=55,file='data_EMBM',status='old')
read(unit=55,nml=ini_embm_nml)
close(unit=55)

lenin = lnsig1(indir_name)
if (indir_name(lenin:lenin).ne.'/') then
!   This 'if' checks for a terminal slash symbol
    lenin = lenin + 1
    indir_name(lenin:lenin) = '/'
end if

lenout = lnsig1(outdir_name)
if (outdir_name(lenout:lenout).ne.'/') then
!   This 'if' checks for a terminal slash symbol
    lenout = lenout + 1
    outdir_name(lenout:lenout+1) = '/'
end if

lentdata = lnsig1(tdatafile)
lenqdata = lnsig1(qdatafile)

END SUBROUTINE read_goin_EMBM


! =====================================================================
! Read the local goin_GOLD file for the following information:
! 
!    indir_name
!    outdir_name
!    tdatafile
!    sdatafile
!
SUBROUTINE read_goin_GOLD(indir_name, lenin, &
                          outdir_name, lenout, &
                          tdatafile, lentdata, &
                          sdatafile, lensdata, lout, world, &
                          tsinterp, tdata_scaling, tdata_offset, &
                          tdata_varname, &
                          tdata_missing, sdata_scaling, &
                          sdata_offset, &
                          sdata_varname, sdata_missing, &
                          saln0,igrid)
IMPLICIT NONE

! string length function
INTEGER :: lnsig1

! GOLD input/output directory
INTEGER :: lenin, lenout
CHARACTER(LEN=200) :: indir_name, outdir_name

! GOLD T/Q data files
INTEGER :: lentdata, lensdata
CHARACTER(LEN=128) :: tdatafile, sdatafile
CHARACTER(LEN=25) ::  tdata_varname,sdata_varname
REAL :: tdata_missing,tdata_scaling,tdata_offset
REAL :: sdata_missing,sdata_scaling,sdata_offset
LOGICAL :: tsinterp

! File extension
CHARACTER(LEN=3) :: lout
CHARACTER(LEN=6) :: world

! File inquiry
LOGICAL :: exists

! Variables in the namelist we are not interested in here
INTEGER :: igrid, npstp, iwstp, itstp, ianav, conserv_per
INTEGER :: nyear, iconv, eos, imld, iediff, ieos
LOGICAL :: dosc, diso, ctrl_diagend
REAL :: yearlen, temp0, temp1, rel, scf, adrag, hosing
REAL :: hosing_trend, nyears_hosing, albocn, gust, ene_tune
REAL :: mldpebuoycoeff, mldketaucoeff, mldwindkedec
REAL :: ediff0, ediffpow1, ediffpow2, ediffvar, ssmaxsurf
REAL :: ssmaxdeep, saln0
REAL, DIMENSION(2) :: diff
CHARACTER (LEN=20) :: ans, fwanomin, cmip_model, netin
CHARACTER (LEN=20) :: netout, ascout, filenetin, dirnetout, lin
CHARACTER(LEN=200) :: rstdir_name

! namelist for reading initialisation data
NAMELIST /ini_gold_nml/indir_name,outdir_name,rstdir_name
NAMELIST /ini_gold_nml/igrid,world
NAMELIST /ini_gold_nml/npstp,iwstp,itstp,ianav
NAMELIST /ini_gold_nml/conserv_per,ans,yearlen,nyear
NAMELIST /ini_gold_nml/temp0,temp1,rel,scf,diff,adrag
NAMELIST /ini_gold_nml/hosing,hosing_trend,nyears_hosing
NAMELIST /ini_gold_nml/fwanomin,cmip_model,albocn
NAMELIST /ini_gold_nml/gust,ene_tune,iconv
NAMELIST /ini_gold_nml/imld,mldpebuoycoeff,mldketaucoeff
NAMELIST /ini_gold_nml/mldwindkedec
NAMELIST /ini_gold_nml/iediff,ediff0,ediffpow1,ediffpow2
NAMELIST /ini_gold_nml/ediffvar
NAMELIST /ini_gold_nml/ieos
NAMELIST /ini_gold_nml/ssmaxsurf,ssmaxdeep
NAMELIST /ini_gold_nml/tdatafile,sdatafile
NAMELIST /ini_gold_nml/tdata_varname,sdata_varname
NAMELIST /ini_gold_nml/tdata_missing,sdata_missing
NAMELIST /ini_gold_nml/tdata_scaling,sdata_scaling
NAMELIST /ini_gold_nml/tdata_offset,sdata_offset
NAMELIST /ini_gold_nml/tsinterp
NAMELIST /ini_gold_nml/lout,netin
NAMELIST /ini_gold_nml/netout,ascout,filenetin,dirnetout,lin
NAMELIST /ini_gold_nml/dosc,diso
NAMELIST /ini_gold_nml/ctrl_diagend
NAMELIST /ini_gold_nml/saln0

! Process the GOLD goin file
INQUIRE(FILE='data_GOLD', EXIST=exists)
IF (.NOT. exists) THEN
    PRINT*,'Cannot find ./data_GOLD'
    STOP
END IF

! Read the EMBM GOIN file
open(unit=55,file='data_GOLD',status='old')
read(unit=55,nml=ini_gold_nml)
close(unit=55)

lenin = lnsig1(indir_name)
if (indir_name(lenin:lenin).ne.'/') then
!   This 'if' checks for a terminal slash symbol
    lenin = lenin + 1
    indir_name(lenin:lenin) = '/'
end if

lenout = lnsig1(outdir_name)
if (outdir_name(lenout:lenout).ne.'/') then
!   This 'if' checks for a terminal slash symbol
    lenout = lenout + 1
    outdir_name(lenout:lenout+1) = '/'
end if

lentdata = lnsig1(tdatafile)
lensdata = lnsig1(sdatafile)

END SUBROUTINE read_goin_GOLD
